<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<metAname="viewport" content="width=device-width,initial-scale=1" />
<title>AWS SAA-C03 - Practice exam</title>
<style>
  body{font-family:Segoe UI,Arial,sans-serif;background:#f3f6ff;padding:20px}
  .card{max-width:900px;margin:0 auto;background:#fff;border-radius:10px;box-shadow:0 6px 24px rgba(0,0,0,.12);overflow:hidden}
  /* Improved header and meta styles */
  header{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;padding:18px 20px;display:flex;align-items:center;justify-content:space-between;gap:18px}
  header .header-left{display:flex;flex-direction:column;}
  header h1{margin:0;font-size:20px;letter-spacing:0.2px;font-weight:700}
  header .subtitle{font-size:12px;opacity:0.9;margin-top:4px}
  header .header-right{display:flex;align-items:center;gap:10px}
  .meta{display:flex;gap:12px;padding:12px 18px;background:#fbfdff;border-bottom:1px solid #eef2ff;align-items: center}
  /* progress styling for native progress element */
  .progress{height:10px;background:#eef2ff;border-radius:999px;overflow:hidden;width:100%;max-width:360px;-webkit-appearance:none;appearance:none;border:0}
  .progress::-webkit-progress-bar{background:transparent}
  .progress::-webkit-progress-value{background:linear-gradient(90deg,#667eea,#764ba2);border-radius:999px}
  .progress::-moz-progress-bar{background:linear-gradient(90deg,#667eea,#764ba2);border-radius:999px}
  .save-indicator{display:flex;align-items:center;gap:8px;font-size:13px;color:#444}
  @keyframes pulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.4);opacity:0.6}100%{transform:scale(1);opacity:1}}
  /* developer credit styling */
  .dev-link{font-weight:700;color:#fff;text-decoration:none}
  .dev-link:hover{text-decoration:underline;transform:translateY(-1px);transition:all .15s}
  .footer-icon svg{vertical-align:middle;margin-left:6px;fill:currentColor;width:16px;height:16px}
  .container{padding:20px}
  .qtext{white-space:pre-wrap;font-size:16px;color:#222;margin-bottom:12px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  button{padding:10px 14px;border-radius:8px;border:0;cursor:pointer;font-weight:600}
  .controls button{display:none}
  #startExamBtn, #createReviewBtn{display:inline-block !important}
  .primary{background:#667eea;color:#fff}
  .secondary{background:#6c757d;color:#fff}
  .bookmark{background:#ffc107;color:#000}
  .answerBox{margin-top:14px;display:none}
  .answerBox.visible{display:block}
  input[type="text"]{width:100%;padding:10px;border-radius:8px;border:1px solid #dfe7ff;font-size:15px}
  .welcome-section{text-align:center;padding:40px 20px;background:linear-gradient(135deg,#667eea15,#764ba215);border-radius:12px;margin:20px 0}
  .welcome-section h2{color:#667eea;font-size:24px;margin-bottom:20px}
  .exam-controls-section{display:flex;flex-direction:column;align-items:center;gap:15px;margin:20px 0;padding:20px;background:#fbfdff;border-radius:10px;border:2px solid #667eea;box-sizing:border-box;overflow:hidden}
  .exam-controls-section label{font-weight:700;color:#333;font-size:14px}
  .exam-controls-section select{width:100%;max-width:480px;padding:10px 12px;border-radius:8px;border:2px solid #667eea;background:#fff;font-size:14px;cursor:pointer;box-sizing:border-box;outline:none}
  .exam-controls-section select:focus{box-shadow:0 0 0 3px rgba(102,126,234,.25);border-color:#667eea}
  .exam-controls-section button{padding:10px 20px;font-size:14px;min-width:150px}
  .answer-panel{background:#f8f9fb;padding:12px;border-radius:8px;margin-top:12px;display:none}
  .options-list{display:flex;flex-direction:column;gap:8px;margin-top:12px}
  .option-btn{padding:10px 12px;border-radius:8px;border:1px solid #e6ecff;background:#fff;cursor:pointer;text-align:left}
  .option-btn:hover{background:#eef4ff}
  .option-btn.selected{background:#667eea;color:#fff;border-color:#667eea}
  .option-btn:disabled{opacity:0.5;cursor:not-allowed}
  @media (max-width:768px){body{padding:10px}.card{border-radius:6px}header{padding:12px}.meta{flex-wrap:wrap;gap:6px;padding:8px 12px;font-size:12px}#examControls{flex-wrap:wrap;width:100%;gap:4px;margin-top:8px;margin-left:0 !important}#examControls label,#examControls select{font-size:12px}#examControls button{padding:4px 8px;font-size:12px}.container{padding:12px}.qtext{font-size:14px}.controls{flex-direction:column}.controls button{width:100%}.answerBox input{font-size:14px;padding:8px}.option-btn{padding:8px 10px;font-size:14px}.welcome-section{padding:20px 10px}.welcome-section h2{font-size:18px}.exam-controls-section{padding:15px}.exam-controls-section select{max-width:100%}.exam-controls-section button{width:100%;min-width:unset}footer{font-size:11px;padding:10px}}
  .confetti-container{pointer-events:none;position:fixed;inset:0;overflow:hidden;z-index:9999}
  .confetti-piece{position:absolute;width:10px;height:14px;opacity:0.95;transform-origin:center;will-change:transform,top,left}
  @keyframes confetti-fall{0%{transform:translateY(-10vh) rotate(0)}100%{transform:translateY(110vh) rotate(720deg)}}
  .result{padding:18px}
  .chart-wrap{display:flex;justify-content:center;align-items:center;margin:10px 0}
  .chart-box{width:180px;height:180px;display:flex;align-items:center;justify-content:center;position:relative}
  #resultChart{width:180px;height:180px}
  .chart-center{position:absolute;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none}
  .chart-center .pct{font-weight:800;font-size:20px}
  .chart-center .status{font-size:13px;font-weight:700;margin-top:6px}
  .chart-center .label{font-size:12px;color:#666}
  .wrong-list{margin-top:12px;display:none}
  .wrong-list.visible{display:block}
  .wrong-item{padding:10px;border-radius:8px;background:#fff7f7;border:1px solid #ffd6d6;margin-bottom:8px}
  .results-actions{display:flex;gap:8px;margin-top:12px;justify-content:center;flex-wrap:wrap}
  footer{padding:14px;background:#fbfdff;border-top:1px solid #eef2ff;text-align:center}
  .hidden{display:none}
</style>
</head>
<body>
  <div class="card">
    <header>
      <div class="header-left">
        <h1>AWS Certified Solutions Architect – Practice Exam</h1>
        <div class="subtitle">SAA-C03 style questions · lightweight offline progress save</div>
      </div>
      <div class="header-right">
        <small style="opacity:.95">Quick practice — built for fast review</small>
      </div>
    </header>

    <div class="meta">
      <div id="progressMeta">Question: 0 / 0</div>
      <div id="percentMeta">Progress: 0%</div>
      <div style="flex:1;display:flex;align-items:center;justify-content:flex-start">
        <progress id="progressBar" class="progress" value="0" max="100" aria-label="exam progress"></progress>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <div id="timerDisplay" style="font-weight:700;color:#222;min-width:110px;text-align:center">00:00</div>
        <button id="pauseResumeBtn" class="secondary" style="padding:6px 10px;border-radius:8px;display:none;min-width:70px">Pause</button>
      </div>
      <div id="idMeta">ID: -</div>
      <div id="saveMeta" class="save-indicator" aria-live="polite">
        <span class="spinner" id="saveSpinner" aria-hidden="true"></span>
        <span class="status" id="saveStatus">Last saved: -</span>
      </div>
    </div>

    <div class="container" id="main">
      <div id="welcomeSection" class="welcome-section">
        <h2>AWS Certified Solutions Architect Associate</h2>
        <div class="exam-controls-section">
          <label for="examSelect">Select Exam:</label>
          <select id="examSelect" style="padding:6px;border-radius:6px;border:1px solid #dfe7ff;background:#fff"></select>
          <button id="startExamBtn" class="primary" style="padding:10px 20px;font-size:14px;min-width:150px">Start Exam</button>
        </div>
      </div>

      <div class="qtext" id="questionText" style="display:none">Loading question...</div>
      <div id="optionsList" class="options-list" aria-live="polite"></div>

      <div class="answerBox">
        <label for="userAnswer" style="display:block;margin-bottom:6px;font-weight:600">Your answer (required):</label>
        <input type="text" id="userAnswer" placeholder="Type answer or option letter (e.g., A, B, C)"/>
      </div>

      <div class="controls">
        <button class="primary" id="showBtn">Show Answer</button>
        <button class="secondary" id="nextBtn" disabled>Next →</button>
        <button class="secondary" id="prevBtn" disabled>← Prev</button>
        <button class="bookmark" id="bookmarkBtn">☆ Bookmark</button>
        <button class="secondary" id="finishBtn">Finish Exam</button>
        <button class="primary" id="saveProgressBtn">Save Progress</button>
        <button class="secondary" id="resetProgressBtn">Reset Progress</button>
      </div>

      <div class="answer-panel" id="answerPanel">
        <div style="font-weight:700;color:#198754">Correct / Source answer:</div>
        <div id="answerText" style="white-space:pre-wrap;margin-top:6px;color:#333"></div>
      </div>
    </div>

    <div id="results" class="hidden">
      <div class="result">
        <h3>Results</h3>
          <div class="chart-wrap">
            <div class="chart-box">
              <canvas id="resultChart" width="180" height="180"></canvas>
              <div class="chart-center">
                <div class="pct" id="chartPct">0%</div>
                <div class="status" id="chartStatus"></div>
                <div class="label" id="chartLabel">Status</div>
              </div>
            </div>
          </div>
          <div class="results-actions">
            <button class="primary" id="restartBtn">Retake</button>
            <button class="secondary" id="newExamBtn">New Exam</button>
            <button class="secondary" id="toggleReviewBtn">Review Questions</button>
          </div>
          <div id="scoreSummary"></div>
        <div class="wrong-list" id="wrongList"></div>
      </div>
    </div>

    <footer>
      <small> Developed by 
        <a href="https://www.linkedin.com/in/laxman-singh-2b912316/" target="_blank" rel="noopener noreferrer" class="dev-link" id="devLink">
          LKY
          <span class="footer-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.761 0 5-2.239 5-5v-14c0-2.761-2.239-5-5-5zm-11.75 19h-2.5v-8.75h2.5v8.75zm-1.25-10c-.828 0-1.5-.672-1.5-1.5s.672-1.5 1.5-1.5 1.5.672 1.5 1.5-.672 1.5-1.5 1.5zm12 10h-2.5v-4.5c0-1.073-.927-1.5-1.25-1.5s-1.25.427-1.25 1.5v4.5h-2.5v-8.75h2.5v1.25c.693-1.048 2.25-1.25 3.75-1.25 2.25 0 4 1.5 4 4.75v3.75z"/>
            </svg>
          </span>
        </a>
      </small>
    </footer>
  </div>

<script>
let questions = [];
let currentIndex = 0;
let userResponses = []; // {id, user, correct, correctText}
let bookmarks = JSON.parse(localStorage.getItem('aws-exam-bookmarks')||'[]');
let awaitingContinue = false;
let currentExamFile = null;
const LAST_EXAM_KEY = 'aws-exam-last';
const stateKeyFor = (exam)=> `aws-exam-state-${exam||'default'}`;

const qText = document.getElementById('questionText');
const optionsList = document.getElementById('optionsList');
const answerText = document.getElementById('answerText');
const answerPanel = document.getElementById('answerPanel');
const userInput = document.getElementById('userAnswer');
const showBtn = document.getElementById('showBtn');
const nextBtn = document.getElementById('nextBtn');
const prevBtn = document.getElementById('prevBtn');
const bookmarkBtn = document.getElementById('bookmarkBtn');
const finishBtn = document.getElementById('finishBtn');
const progressMeta = document.getElementById('progressMeta');
const percentMeta = document.getElementById('percentMeta');
const idMeta = document.getElementById('idMeta');
const resultsPanel = document.getElementById('results');
const mainPanel = document.getElementById('main');
const scoreSummary = document.getElementById('scoreSummary');
const wrongList = document.getElementById('wrongList');

// exam selector + timer elements
const examSelect = document.getElementById('examSelect');
const timerDisplay = document.getElementById('timerDisplay');
const startExamBtn = document.getElementById('startExamBtn');
const createReviewBtn = document.getElementById('createReviewBtn');
const metaBar = document.querySelector('.meta');

let examIndexList = [];
let examTimerInterval = null;
let examTimeLeft = 0; // seconds
let currentExamIsReview = false;
let examInProgress = false;
let examPaused = false; // whether the exam timer is currently paused

// Button state management
function updateButtonStates() {
  const examLoaded = questions.length > 0;
  const saveProgressBtn = document.getElementById('saveProgressBtn');
  const resetProgressBtn = document.getElementById('resetProgressBtn');
  const pauseResumeBtn = document.getElementById('pauseResumeBtn');
  
  // Show/hide and enable/disable buttons based on exam state
  const questionButtons = [showBtn, nextBtn, prevBtn, bookmarkBtn, finishBtn, saveProgressBtn, resetProgressBtn, createReviewBtn, pauseResumeBtn];
  questionButtons.forEach(btn => {
    if (btn) {
      btn.style.display = examLoaded ? 'inline-block' : 'none';
      btn.disabled = !examLoaded;
    }
  });
  
  // Special enable/disable logic
  if (examLoaded) {
    nextBtn.disabled = userInput.value.trim().length === 0;
    prevBtn.disabled = currentIndex === 0;
  }
}

function updateTimerDisplay() {
  const s = Math.max(0, Math.floor(examTimeLeft));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  timerDisplay.textContent = `${mm}:${ss}`;
}

function startTimer(totalSeconds) {
  stopTimer();
  examTimeLeft = totalSeconds;
  updateTimerDisplay();
  examPaused = false;
  updatePauseButton();
  examTimerInterval = setInterval(()=>{
    examTimeLeft -= 1;
    updateTimerDisplay();
    if (examTimeLeft <= 0) {
      stopTimer();
      alert('Time is up — finishing exam.');
      finishExam();
    }
  }, 1000);
}

function stopTimer(){ if (examTimerInterval) { clearInterval(examTimerInterval); examTimerInterval=null; } }

function updatePauseButton(){
  const btn = document.getElementById('pauseResumeBtn');
  if (!btn) return;
  if (examPaused) { btn.textContent = 'Resume'; btn.style.background = '#ffc107'; }
  else { btn.textContent = 'Pause'; btn.style.background = '#6c757d'; }
  // only show pause when an exam is loaded
  btn.style.display = questions.length>0 ? 'inline-block' : 'none';
}

// Pause/Resume toggle handler
document.getElementById('pauseResumeBtn').addEventListener('click', ()=>{
  if (!examInProgress) return;
  if (!examPaused) {
    // pause
    stopTimer();
    examPaused = true;
    updatePauseButton();
    // persist paused state
    autosave();
  } else {
    // resume
    examPaused = false;
    updatePauseButton();
    // resume timer from remaining time
    startTimer(Math.max(1, Math.floor(examTimeLeft)));
    autosave();
  }
});

function handleExamToggle() {
  if (examInProgress) {
    // Stop exam
    if (confirm('Stop exam and stop timer?')) {
      stopTimer();
      examInProgress = false;
      startExamBtn.textContent = 'Start';
      startExamBtn.className = 'primary';
        startExamBtn.style.display = 'inline-block';
        document.querySelector('.answerBox').classList.remove('visible');
        document.getElementById('welcomeSection').style.display = 'block';
        document.getElementById('questionText').style.display = 'none';
        const controls = document.querySelector('.controls');
        const options = document.getElementById('optionsList');
        if (controls) controls.style.display = 'none';
        if (options) options.style.display = 'none';
      examPaused = false;
      updateButtonStates();
    }
  } else {
    // Start exam
    const sel = examSelect.value;
    if (!sel) { alert('Please select an exam first'); return; }
    if (examIndexList.length === 0) { alert('Exam list not loaded yet. Please wait and try again.'); return; }
    currentExamFile = sel;
    
    // fetch exam file from exams/ folder
    if (sel === 'review') {
      // load from localStorage review list
      const review = getReviewList();
      if (!review || review.length===0) { alert('Review exam empty.'); return; }
      examLoadedFromReview(review);
    } else {
      fetch(sel).then(r=>{
      if(!r.ok) throw new Error('Failed to fetch exam file');
      return r.json();
      }).then(data=>{
        // set questions from selected file
        const qarr = Array.isArray(data.questions) ? data.questions : (Array.isArray(data) ? data : []);
      if (qarr.length===0) { alert('Selected exam has no questions'); return; }
      questions = qarr.map(it=>{
        let answerText = '';
        if (it.correct_answer) {
          let optText = '';
          if (it.options && it.options[it.correct_answer]) optText = ' — ' + it.options[it.correct_answer];
          answerText = `${it.correct_answer}${optText}` + (it.explanation ? '\n\n' + it.explanation : '');
        } else if (it.answer) {
          answerText = it.answer;
        } else {
          answerText = 'Answer not available in source data.';
        }
        const correctRaw = it.correct_answer || null;
        let correctAnswers = correctRaw ? correctRaw.split(',').map(s=>s.trim()).filter(Boolean) : (it.answer ? [it.answer.trim()] : []);
        // If single answer but looks like multiple letters (e.g., "BD"), split into individual characters
        if (correctAnswers.length === 1 && /^[A-Z]+$/.test(correctAnswers[0])) {
          correctAnswers = correctAnswers[0].split('');
        }
        const multi = correctAnswers.length > 1;
        return { id: it.id || it.number, q: it.question || it.content || '', a: answerText, hasAnswer: !!(it.correct_answer || it.answer), options: it.options || null, correct_raw: correctRaw, correct_answers: correctAnswers, multi: multi };
      });
      // init responses and UI
      questions.sort((x,y)=>parseInt(x.id)-parseInt(y.id));
      userResponses = questions.map(q=>({id:q.id,user:'',correct:false,correctText:q.a}));
      currentIndex = 0;
      const restored = restoreStateForExam(currentExamFile);
      localStorage.setItem(LAST_EXAM_KEY, currentExamFile);
      mainPanel.classList.remove('hidden');
      resultsPanel.classList.add('hidden');
      document.getElementById('welcomeSection').style.display = 'none';
      document.getElementById('questionText').style.display = 'block';
      document.querySelector('.answerBox').classList.add('visible');
      const controls = document.querySelector('.controls');
      const options = document.getElementById('optionsList');
      if (controls) controls.style.display = 'flex';
      if (options) options.style.display = '';
      if (metaBar) metaBar.style.display = 'flex';
      loadQuestion(currentIndex || 0);
      startExamBtn.style.display = 'inline-block';
      examInProgress = true;
      startExamBtn.textContent = 'Stop';
      startExamBtn.className = 'secondary';
      // start countdown timer (default: 100 minutes)
      const resumeTime = restored && typeof restored.timeLeft === 'number' ? restored.timeLeft : (100 * 60);
      // If the saved state indicates the exam was paused, restore paused state without starting the timer
      if (restored && restored.examPaused) {
        examPaused = true;
        examTimeLeft = resumeTime;
        updateTimerDisplay();
        updatePauseButton();
        // ensure timer is not running
        stopTimer();
      } else {
        examPaused = false;
        startTimer(resumeTime);
      }
    }).catch(err=>{ alert('Failed to start exam: ' + err.message); });
    }
  }
}

startExamBtn.addEventListener('click', handleExamToggle);

function examLoadedFromReview(reviewArr) {
  currentExamFile = 'review';
  const qarr = reviewArr;
  questions = qarr.map(it=>{
    let answerText = '';
    if (it.correct_answer) {
      let optText = '';
      if (it.options && it.options[it.correct_answer]) optText = ' — ' + it.options[it.correct_answer];
      answerText = `${it.correct_answer}${optText}` + (it.explanation ? '\n\n' + it.explanation : '');
    } else if (it.answer) {
      answerText = it.answer;
    } else {
      answerText = 'Answer not available in source data.';
    }
    const correctRaw = it.correct_answer || null;
    let correctAnswers = correctRaw ? correctRaw.split(',').map(s=>s.trim()).filter(Boolean) : (it.answer ? [it.answer.trim()] : []);
    // If single answer but looks like multiple letters (e.g., "BD"), split into individual characters
    if (correctAnswers.length === 1 && /^[A-Z]+$/.test(correctAnswers[0])) {
      correctAnswers = correctAnswers[0].split('');
    }
    const multi = correctAnswers.length > 1;
    return { id: it.id || it.number, q: it.question || it.content || '', a: answerText, hasAnswer: !!(it.correct_answer || it.answer), options: it.options || null, correct_raw: correctRaw, correct_answers: correctAnswers, multi: multi };
  });
  questions.sort((x,y)=>parseInt(x.id)-parseInt(y.id));
  userResponses = questions.map(q=>({id:q.id,user:'',correct:false,correctText:q.a}));
  currentIndex = 0;
  const restored = restoreStateForExam(currentExamFile);
  localStorage.setItem(LAST_EXAM_KEY, currentExamFile);
  currentExamIsReview = true;
  examInProgress = true;
  mainPanel.classList.remove('hidden');
  resultsPanel.classList.add('hidden');
  document.getElementById('welcomeSection').style.display = 'none';
  document.getElementById('questionText').style.display = 'block';
  document.querySelector('.answerBox').classList.add('visible');
  if (metaBar) metaBar.style.display = 'flex';
  loadQuestion(currentIndex || 0);
  startExamBtn.style.display = 'inline-block';
  startExamBtn.textContent = 'Stop';
  startExamBtn.className = 'secondary';
  // start countdown timer (default: 100 minutes)
  const resumeTime = restored && typeof restored.timeLeft === 'number' ? restored.timeLeft : (100 * 60);
  if (restored && restored.examPaused) {
    examPaused = true;
    examTimeLeft = resumeTime;
    updateTimerDisplay();
    updatePauseButton();
    stopTimer();
  } else {
    examPaused = false;
    startTimer(resumeTime);
  }
}

// manual create/update review exam from current session wrongs
if (createReviewBtn) {
  createReviewBtn.addEventListener('click', ()=>{
    const wrongs = [];
    for (let i=0;i<userResponses.length;i++){
      const r = userResponses[i];
      if (!r.correct) wrongs.push({index:i, id:r.id, user:r.user||''});
    }
    if (wrongs.length===0) { alert('No wrong questions in current session to add.'); return; }
    addToReviewFromWrongs(wrongs);
    updateReviewOption();
    alert('Added ' + wrongs.length + ' questions to Review exam.');
  });
}

async function loadQuestionsFromFile() {
  try {
    currentExamFile = 'all_records';
    const r = await fetch('all_records.json');
    if(!r.ok) throw new Error('Failed to fetch all_records.json');
    const data = await r.json();
    questions = [];

    if (Array.isArray(data.questions)) {
      data.questions.forEach(it => {
        let answerText = '';
        if (it.correct_answer) {
          let optText = '';
          if (it.options && it.options[it.correct_answer]) optText = ' — ' + it.options[it.correct_answer];
          answerText = `${it.correct_answer}${optText}` + (it.explanation ? '\n\n' + it.explanation : '');
        } else if (it.answer) {
          answerText = it.answer;
        } else {
          answerText = 'Answer not available in source data.';
        }
        // derive correct answers array and multi-select flag
        const correctRaw = it.correct_answer || null;
        let correctAnswers = correctRaw ? correctRaw.split(',').map(s=>s.trim()).filter(Boolean) : (it.answer ? [it.answer.trim()] : []);
        // If single answer but looks like multiple letters (e.g., "BD"), split into individual characters
        if (correctAnswers.length === 1 && /^[A-Z]+$/.test(correctAnswers[0])) {
          correctAnswers = correctAnswers[0].split('');
        }
        const multi = correctAnswers.length > 1;
        questions.push({
          id: it.id || it.number,
          q: it.question || it.content || '',
          a: answerText,
          hasAnswer: !!(it.correct_answer || it.answer),
          options: it.options || null,
          correct_raw: correctRaw,
          correct_answers: correctAnswers,
          multi: multi
        });
      });
    } else {
      // Backwards-compatible parsing for files that use complete_qa_pairs/incomplete_entries
      if (Array.isArray(data.complete_qa_pairs)) {
        data.complete_qa_pairs.forEach(it => questions.push({id: it.number, q: it.question || it.content || '', a: it.answer || '', hasAnswer: !!it.has_answer}));
      }
      if (Array.isArray(data.incomplete_entries)) {
        data.incomplete_entries.forEach(it => questions.push({id: it.number, q: it.content || '', a: it.answer || 'Answer not available in source data.', hasAnswer: !!it.has_answer}));
      }
    }

    // Sort by numeric id when possible
    questions.sort((x,y)=>parseInt(x.id)-parseInt(y.id));
    if (questions.length===0) {
      qText.textContent = 'No questions found in all_records.json';
      return;
    }

    // init responses
    userResponses = questions.map(q=>({id:q.id,user:'',correct:false,correctText:q.a}));

    currentExamIsReview = false;

    const restored = restoreStateForExam(currentExamFile);
    localStorage.setItem(LAST_EXAM_KEY, currentExamFile);
    loadQuestion(currentIndex || 0);
  } catch (err) {
    qText.textContent = 'Error loading questions: ' + err.message + '\nEnsure file json is served over HTTP.';
  }
}

function loadQuestion(index) {
  currentIndex = index;
  const q = questions[currentIndex];
  qText.textContent = q.q || '(no text)';
  answerText.textContent = q.a || '(no answer)';
  answerPanel.style.display = 'none';
  userInput.value = userResponses[currentIndex].user || '';
    // render options
  optionsList.innerHTML = '';
  if (q.options && typeof q.options === 'object') {
    // sort keys like A,B,C...
    Object.keys(q.options).sort().forEach(key => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'option-btn';
      btn.dataset.opt = key;
      btn.innerHTML = `<strong>${key}.</strong> ${escapeHtml(q.options[key])}`;
      if (q.multi) {
        btn.addEventListener('click', (e)=>{
          e.preventDefault();
          // toggle selection for multi-select
          btn.classList.toggle('selected');
          const selected = Array.from(optionsList.children).filter(c=>c.classList.contains('selected')).map(c=>c.dataset.opt);
          userInput.value = selected.join(', ');
          toggleButtons();
          userInput.dispatchEvent(new Event('input'));
        });
      } else {
        btn.addEventListener('click', ()=>{
          // single select behavior
          userInput.value = key;
          Array.from(optionsList.children).forEach(c=>c.classList.remove('selected'));
          btn.classList.add('selected');
          toggleButtons();
          userInput.dispatchEvent(new Event('input'));
        });
      }
      optionsList.appendChild(btn);
    });
    // restore previous selection if any
    const prev = userResponses[currentIndex].user;
    if (prev) {
      const prevSet = prev.split(',').map(s=>s.trim().toUpperCase());
      Array.from(optionsList.children).forEach(c=>{
        if (prevSet.includes(c.dataset.opt.toUpperCase()) || prevSet.includes(q.options[c.dataset.opt].toUpperCase())) c.classList.add('selected');
      });
    }
    // ensure buttons are enabled (they may have been disabled after showing answer)
    Array.from(optionsList.children).forEach(c=>c.disabled = false);
  }
  updateMeta();
  toggleButtons();
  updateBookmarkBtn();
  // autosave position when question changed
  autosave();
  updateButtonStates();
}

function updateMeta() {
  progressMeta.textContent = `Question: ${currentIndex+1} / ${questions.length}`;
  const pct = Math.round(((currentIndex+1)/questions.length)*100);
  percentMeta.textContent = `Progress: ${pct}%`;
  // update native progress element value for accessibility
  const pb = document.getElementById('progressBar');
  if (pb) { try { pb.value = pct; pb.setAttribute('aria-valuenow', String(pct)); } catch(e){} }
  idMeta.textContent = `ID: ${questions[currentIndex].id}`;
}

function toggleButtons() {
  nextBtn.disabled = userInput.value.trim().length === 0;
  prevBtn.disabled = currentIndex===0;
}

userInput.addEventListener('input', ()=> {
  // update button selections if this is a multi-select question
  const q = questions[currentIndex];
  if (q && q.multi) {
    const inputVal = userInput.value.trim();
    const selected = inputVal ? inputVal.split(',').map(s=>s.trim().toUpperCase()) : [];
    Array.from(optionsList.children).forEach(btn=>{
      if (selected.includes(btn.dataset.opt.toUpperCase())) {
        btn.classList.add('selected');
      } else {
        btn.classList.remove('selected');
      }
    });
  }
  toggleButtons();
  updateButtonStates();
  scheduleAutosave();
});

showBtn.addEventListener('click', ()=> {
  // toggle show/hide answer
  const isShowing = answerPanel.style.display === 'block';
  answerPanel.style.display = isShowing ? 'none' : 'block';
  showBtn.textContent = isShowing ? 'Show Answer' : 'Hide Answer';
});

nextBtn.addEventListener('click', ()=> {
  // two-step: first click evaluates and shows answer (with celebration if correct), second click continues to next question
  if (!awaitingContinue) {
    // evaluate and reveal
    const user = userInput.value.trim();
    if(user.length===0) { alert('Please enter your answer before proceeding.'); return; }

    const q = questions[currentIndex];
    let correctFlag = false;
    if (q.multi && Array.isArray(q.correct_answers) && q.correct_answers.length>0) {
      const selected = Array.from(optionsList.children).filter(c=>c.classList.contains('selected')).map(c=>c.dataset.opt.toUpperCase().trim());
      const selSet = new Set(selected);
      const corrSet = new Set(q.correct_answers.map(s=>s.toUpperCase().trim()));
      correctFlag = selSet.size === corrSet.size && [...selSet].every(x=>corrSet.has(x));
    } else if (Array.isArray(q.correct_answers) && q.correct_answers.length===1) {
      const correctLetter = q.correct_answers[0].toUpperCase().trim();
      const userVal = user.toUpperCase().trim();
      if (userVal === correctLetter) correctFlag = true;
      else if (q.options && q.options[correctLetter] && normalize(user) === normalize(q.options[correctLetter])) correctFlag = true;
      else correctFlag = normalize(user) === normalize(q.a || '');
    } else {
      correctFlag = normalize(user) === normalize(q.a || '');
    }

    userResponses[currentIndex].user = user;
    userResponses[currentIndex].correct = correctFlag;

    // if this is a review exam and user got it correct, remove it from review list
    if (correctFlag && currentExamIsReview) {
      const q = questions[currentIndex];
      if (q && q.id) removeFromReviewById(q.id);
    }

    // reveal answer panel
    answerPanel.style.display = 'block';

    // celebration when correct
    if (correctFlag) showCelebration();

    // enter awaiting continue state
    awaitingContinue = true;
    nextBtn.textContent = 'Continue';
    nextBtn.disabled = false;
    userInput.disabled = true;
    Array.from(optionsList.children).forEach(c=>c.disabled = true);
  } else {
    // continue to next
    awaitingContinue = false;
    nextBtn.textContent = 'Next →';
    userInput.disabled = false;
    Array.from(optionsList.children).forEach(c=>c.disabled = false);
    clearConfetti();
    if (currentIndex < questions.length-1) {
      loadQuestion(currentIndex+1);
    } else {
      finishExam();
    }
  }
});

prevBtn.addEventListener('click', ()=> {
  if (currentIndex>0) {
    loadQuestion(currentIndex-1);
  }
});

bookmarkBtn.addEventListener('click', ()=> {
  const idx = bookmarks.indexOf(currentIndex);
  if (idx>-1) bookmarks.splice(idx,1);
  else bookmarks.push(currentIndex);
  localStorage.setItem('aws-exam-bookmarks', JSON.stringify(bookmarks));
  updateBookmarkBtn();
  autosave();
});

function updateBookmarkBtn(){
  if (bookmarks.includes(currentIndex)) { bookmarkBtn.textContent='★ Bookmarked'; bookmarkBtn.style.background='#ff6b6b'; }
  else { bookmarkBtn.textContent='☆ Bookmark'; bookmarkBtn.style.background='#ffc107'; }
}

finishBtn.addEventListener('click', ()=> {
  // if current not answered, prompt
  if (userInput.value.trim().length>0 && !userResponses[currentIndex].user) {
    // auto-save current input before finishing
    const user = userInput.value.trim();
    userResponses[currentIndex].user = user;
    userResponses[currentIndex].correct = normalize(user) === normalize((questions[currentIndex].a||'').trim());
  }
  finishExam();
});

// Save / Reset functionality
document.getElementById('saveProgressBtn').addEventListener('click', saveProgress);
document.getElementById('resetProgressBtn').addEventListener('click', resetProgress);

function saveProgress(){
  try{
    saveState(false);
  }catch(e){
    console.warn('Failed to save progress', e);
    alert('Failed to save progress: ' + (e && e.message));
  }
}

// core save helper used by autosave and manual save
function saveState(silent){
  try{
    if (!currentExamFile) return; // no active exam to save
    const stateKey = stateKeyFor(currentExamFile);
    // visual: show saving spinner/status
    const meta = document.getElementById('saveMeta');
    if (meta) meta.classList.add('saving');
    const statusEl = document.getElementById('saveStatus');
    if (statusEl) statusEl.textContent = 'Saving...';

    const state = {
      currentIndex: currentIndex,
      bookmarks: bookmarks,
      userResponses: userResponses.map(r=>({id:r.id,user:r.user,correct:r.correct})),
      awaitingContinue: awaitingContinue,
      showingAnswer: answerPanel.style.display === 'block',
      qIds: questions.map(q=>String(q.id)),
      timeLeft: examTimeLeft,
      examPaused: !!examPaused,
      examFile: currentExamFile
    };
    localStorage.setItem(stateKey, JSON.stringify(state));
    localStorage.setItem(LAST_EXAM_KEY, currentExamFile);
    const now = new Date();
    const ts = now.toLocaleTimeString();
    if (statusEl) statusEl.textContent = `Last saved: ${ts}`;
    if (meta) {
      meta.classList.remove('saving');
      meta.classList.add('saved');
    }
    // remove 'saved' visual indicator after short time
    setTimeout(()=>{
      try{
        if (meta) meta.classList.remove('saved');
      }catch(e){}
    }, 1800);
    if (!silent) alert('Progress saved locally.');
  }catch(e){
    console.warn('Failed to save state', e);
    if (!silent) alert('Failed to save progress: ' + (e && e.message));
  }
}

function getSavedState(examFile){
  if (!examFile) return null;
  try{
    return JSON.parse(localStorage.getItem(stateKeyFor(examFile))||'null');
  }catch(e){
    console.warn('Failed to read saved state', e);
    return null;
  }
}

function restoreStateForExam(examFile){
  const saved = getSavedState(examFile);
  if (!saved || typeof saved !== 'object') return null;
  // basic guard: ensure question set matches saved snapshot
  if (Array.isArray(saved.qIds)) {
    const curIds = questions.map(q=>String(q.id));
    if (saved.qIds.length !== curIds.length) return null;
    for (let i=0;i<curIds.length;i++) {
      if (String(saved.qIds[i]) !== String(curIds[i])) return null;
    }
  }
  if (typeof saved.currentIndex === 'number' && saved.currentIndex >= 0) {
    currentIndex = Math.min(saved.currentIndex, questions.length - 1);
  }
  if (Array.isArray(saved.bookmarks)) {
    bookmarks = saved.bookmarks;
    localStorage.setItem('aws-exam-bookmarks', JSON.stringify(bookmarks));
  }
  if (Array.isArray(saved.userResponses)) {
    saved.userResponses.forEach(sr => {
      const idx = userResponses.findIndex(ur => String(ur.id) === String(sr.id));
      if (idx > -1) {
        userResponses[idx].user = sr.user || '';
        userResponses[idx].correct = !!sr.correct;
      }
    });
  }
  awaitingContinue = !!saved.awaitingContinue;
  if (saved.showingAnswer) answerPanel.style.display = 'block';
  if (typeof saved.timeLeft === 'number' && saved.timeLeft > 0) examTimeLeft = saved.timeLeft;
  // restore paused state if present
  examPaused = !!saved.examPaused;
  return saved;
}

// autosave helpers
let autosaveTimer = null;
function scheduleAutosave(){
  if (autosaveTimer) clearTimeout(autosaveTimer);
  autosaveTimer = setTimeout(()=>{ autosave(); }, 1500);
}

function autosave(){
  // silent save
  saveState(true);
}

// periodic autosave every 10 seconds
setInterval(()=>{ if (questions.length>0) autosave(); }, 10000);

function resetProgress(){
  if (!confirm('Clear saved progress and bookmarks?')) return;
  try{
    if (questions.length === 0) {
      alert('No exam loaded. Start an exam first.');
      return;
    }
    if (currentExamFile) localStorage.removeItem(stateKeyFor(currentExamFile));
    localStorage.removeItem('aws-exam-bookmarks');
    localStorage.removeItem(LAST_EXAM_KEY);
    bookmarks = [];
    userResponses = questions.map(q=>({id:q.id,user:'',correct:false,correctText:q.a}));
    awaitingContinue = false;
    answerPanel.style.display = 'none';
    loadQuestion(0);
    document.getElementById('welcomeSection').style.display = 'none';
    document.getElementById('questionText').style.display = 'block';
    document.querySelector('.answerBox').classList.add('visible');
    loadQuestion(0);
    startExamBtn.style.display = 'inline-block';
    alert('Progress reset.');
  }catch(e){
    console.warn('Failed to reset progress', e);
    alert('Failed to reset: ' + (e && e.message));
  }
}

function finishExam() {
  // compute results
  stopTimer();
  examInProgress = false;
  startExamBtn.textContent = 'Start';
  startExamBtn.className = 'primary';
  
  let correct = 0;
  const wrongs = [];
  for (let i=0;i<userResponses.length;i++){
    const r = userResponses[i];
    if (r.user && r.correct) correct++;
    else wrongs.push({index:i, id:r.id, user:r.user||'(no answer)', correctText:r.correctText||'(no answer)'});
  }

  // Hide main, show results
  mainPanel.classList.add('hidden');
  resultsPanel.classList.remove('hidden');
  if (metaBar) metaBar.style.display = 'none';

  const percent = Math.round((correct/questions.length)*100);
  const passing = percent >= 72;
  // we display results only in the pie chart center; clear textual status here
  scoreSummary.innerHTML = '';
  // draw result pie chart (chart center will show count and percentage)
  drawResultPie(correct, questions.length, percent, passing);

  wrongList.innerHTML = '';
  if (wrongs.length===0) {
    wrongList.innerHTML = '<div style="padding:10px;background:#e9f8ee;border-radius:8px">All answers correct or provided.</div>';
  } else {
    wrongs.forEach(w=>{
      const div = document.createElement('div');
      div.className='wrong-item';
      div.innerHTML = `<div style="font-weight:700">Q ${parseInt(w.index)+1} (ID: ${w.id})</div>
                       <div style="margin-top:6px;white-space:pre-wrap">${questions[w.index].q}</div>
                       <div style="margin-top:8px"><strong>Your answer:</strong> ${escapeHtml(w.user)}</div>
                       <div style="margin-top:4px;color:#0b5cff"><strong>Correct / Source:</strong> ${escapeHtml(w.correctText)}</div>`;
      wrongList.appendChild(div);
    });
  }
  // automatically append wrong questions to review exam (localStorage)
  try {
    addToReviewFromWrongs(wrongs);
    // refresh review option label
    updateReviewOption();
  } catch (e) { console.warn('Failed to update review exam', e); }
}

document.getElementById('restartBtn').addEventListener('click', ()=>{
  // reset
    document.getElementById('welcomeSection').style.display = 'none';
    document.getElementById('questionText').style.display = 'block';
    document.querySelector('.answerBox').classList.add('visible');
    if (metaBar) metaBar.style.display = 'flex';
  userResponses = questions.map(q=>({id:q.id,user:'',correct:false,correctText:q.a}));
  mainPanel.classList.remove('hidden');
  resultsPanel.classList.add('hidden');
  loadQuestion(0);
});

// New Exam: return to welcome screen to select a different exam
document.getElementById('newExamBtn').addEventListener('click', ()=>{
  stopTimer();
  examInProgress = false;
  resultsPanel.classList.add('hidden');
  mainPanel.classList.remove('hidden');
  const welcome = document.getElementById('welcomeSection');
  const qtext = document.getElementById('questionText');
  const answerBox = document.querySelector('.answerBox');
  const controls = document.querySelector('.controls');
  const options = document.getElementById('optionsList');
  if (welcome) welcome.style.display = 'block';
  if (qtext) qtext.style.display = 'none';
  if (answerBox) answerBox.classList.remove('visible');
  if (controls) controls.style.display = 'none';
  if (options) options.style.display = 'none';
  if (metaBar) metaBar.style.display = 'none';
  startExamBtn.textContent = 'Start';
  startExamBtn.className = 'primary';
  updateButtonStates();
});

// Toggle Review Questions visibility
document.getElementById('toggleReviewBtn').addEventListener('click', ()=>{
  const isVisible = wrongList.classList.contains('visible');
  if (isVisible) {
    wrongList.classList.remove('visible');
    document.getElementById('toggleReviewBtn').textContent = 'Review Questions';
  } else {
    wrongList.classList.add('visible');
    document.getElementById('toggleReviewBtn').textContent = 'Hide Questions';
  }
});

function normalize(s){
  return (s||'').toLowerCase().replace(/\s+/g,' ').trim();
}

// ---- Review exam helpers (localStorage) ----
function getReviewList(){
  try { return JSON.parse(localStorage.getItem('aws-review-questions')||'[]'); } catch(e){ return []; }
}
function saveReviewList(list){
  try { localStorage.setItem('aws-review-questions', JSON.stringify(list)); return true; } catch(e){ console.warn('saveReviewList failed', e); return false; }
}
function addToReviewFromWrongs(wrongs){
  if (!Array.isArray(wrongs) || wrongs.length===0) return;
  const cur = getReviewList();
  const ids = new Set(cur.map(q=>String(q.id)));
  // wrongs contain index,id,user,correctText; map to full question from current questions array
  wrongs.forEach(w=>{
    const qobj = questions[w.index];
    if (!qobj) return;
    if (ids.has(String(qobj.id))) return;
    // store minimal full data
    cur.push({ id: qobj.id, question: qobj.q, options: qobj.options || null, correct_answer: qobj.correct_raw || null, explanation: (qobj.correct_answers && qobj.correct_answers.length)? qobj.a.split('\n\n').slice(1).join('\n\n') : '' });
    ids.add(String(qobj.id));
  });
  saveReviewList(cur);
}
function removeFromReviewById(id){
  const cur = getReviewList();
  const newList = cur.filter(q=>String(q.id)!==String(id));
  saveReviewList(newList);
  updateReviewOption();
}
function updateReviewOption(){
  const opt = document.getElementById('reviewOption');
  if (!opt) return;
  const lst = getReviewList()||[];
  opt.textContent = `Review (${lst.length} items)`;
}

// hook: when user answers correct during review exam, remove from review

function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

// keyboard shortcuts
document.addEventListener('keydown', (e)=>{
  if (e.target.tagName==='INPUT') return;
  if (e.key==='ArrowRight') nextBtn.click();
  if (e.key==='ArrowLeft') prevBtn.click();
  if (e.key===' ') { e.preventDefault(); showBtn.click(); }
});

// Celebration helpers
function showCelebration(){
  clearConfetti();
  const container = document.createElement('div');
  container.className = 'confetti-container';
  const colors = ['#ffc107','#ff6b6b','#6bcB77','#4dabf7','#ff8a65','#b39ddb'];
  const pieces = 36;
  for (let i=0;i<pieces;i++){
    const el = document.createElement('div');
    el.className = 'confetti-piece';
    const left = Math.random()*100;
    const delay = Math.random()*0.4;
    const dur = 1.8 + Math.random()*1.2;
    el.style.left = left + 'vw';
    el.style.top = '-10vh';
    el.style.background = colors[i % colors.length];
    el.style.transform = `rotate(${Math.random()*360}deg)`;
    el.style.animation = `confetti-fall ${dur}s ${delay}s linear forwards`;
    el.style.borderRadius = (Math.random()>0.5? '2px':'50%');
    container.appendChild(el);
  }
  document.body.appendChild(container);
  // remove after animation
  setTimeout(()=>{ clearConfetti(); }, 2600);
}

function clearConfetti(){
  Array.from(document.getElementsByClassName('confetti-container')).forEach(n=>n.remove());
}

// Draw animated result pie on canvas
function drawResultPie(correct, total, percent, passing){
  const canvas = document.getElementById('resultChart');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const size = 180;
  canvas.width = size * dpr;
  canvas.height = size * dpr;
  canvas.style.width = size + 'px';
  canvas.style.height = size + 'px';
  ctx.scale(dpr,dpr);

  const cx = size/2, cy = size/2, r = 72;
  // background circle
  ctx.clearRect(0,0,size,size);
  ctx.beginPath();
  ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.fillStyle = '#f1f3f8';
  ctx.fill();

  const target = Math.max(0, Math.min(1, percent/100));
  const green = '#0b8f3b';
  const red = '#d63333';
  let progress = 0;

  // draw initial background (light ring)
  ctx.clearRect(0,0,size,size);
  ctx.beginPath();
  ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.fillStyle = '#f1f3f8';
  ctx.fill();

  function render(){
    ctx.clearRect(0,0,size,size);

    // background full ring (light)
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fillStyle = '#f1f3f8';
    ctx.fill();

    // draw remainder (full circle in red)
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,-Math.PI/2, -Math.PI/2 + Math.PI*2, false);
    ctx.closePath();
    ctx.fillStyle = red;
    ctx.fill();

    // draw progress (green) on top from 0 -> progress
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,-Math.PI/2, -Math.PI/2 + (Math.PI*2)*progress, false);
    ctx.closePath();
    ctx.fillStyle = green;
    ctx.fill();

    // inner cutout (white)
    ctx.beginPath();
    ctx.arc(cx,cy,r-18,0,Math.PI*2);
    ctx.fillStyle = '#fff';
    ctx.fill();

    // update DOM text and status
    const pctEl = document.getElementById('chartPct');
    const labelEl = document.getElementById('chartLabel');
    const statusEl = document.getElementById('chartStatus');
    pctEl.textContent = percent + '%';
    labelEl.textContent = `${correct} / ${total} correct (${percent}%)`;
    statusEl.textContent = passing ? 'PASS' : 'FAIL';
    // keep status colored by pass/fail; percent stays green to match progress
    pctEl.style.color = green;
    statusEl.style.color = passing ? green : red;

    if (progress < target) {
      progress += Math.min(0.02, (target-progress)/6);
      requestAnimationFrame(render);
    } else {
      progress = target;
      pctEl.textContent = percent + '%';
    }
  }
  render();
}

// initialize
// initialize exam selector and timer
function loadExamList(){
  const tryPaths = ['index.json','exams/index.json'];
  const tryFetch = (paths)=>{
    if (paths.length===0) throw new Error('No index.json found');
    const p = paths[0];
    return fetch(p).then(r=>{
      if(!r.ok) throw new Error('Failed to load exams index');
      return r.json();
    }).catch(()=> tryFetch(paths.slice(1)));
  };
  tryFetch(tryPaths).then(data=>{
    examIndexList = data.parts || [];
    examSelect.innerHTML = '';
    examIndexList.forEach((p, idx)=>{
      const opt = document.createElement('option');
      opt.value = p.file;
      opt.textContent = `Exam ${idx+1} (${p.start_index}-${p.end_index})`;
      examSelect.appendChild(opt);
    });
    // add review option
    const rev = document.createElement('option');
    rev.value = 'review';
    rev.id = 'reviewOption';
    const reviewList = getReviewList();
    rev.textContent = `Review (${(reviewList||[]).length} items)`;
    examSelect.appendChild(rev);
    // set default selection to Exam 1
    examSelect.selectedIndex = 0;
    const lastExam = localStorage.getItem(LAST_EXAM_KEY);
    if (lastExam) {
      const hasLast = Array.from(examSelect.options).some(o=>o.value===lastExam);
      if (hasLast) examSelect.value = lastExam;
    }
    updateTimerDisplay();
    updatePauseButton();
  }).catch(err=>{
    console.warn('Failed to load exam index', err);
    // fallback: try to load all_records.json directly
    try {
      examSelect.innerHTML = '<option value="">No exams found</option>';
    } catch(e){}
    loadQuestionsFromFile();
  }).catch(err=>{
    console.warn('Failed to load exam index', err);
    // fallback: try to load all_records.json directly
    try {
      examSelect.innerHTML = '<option value="">No exams found</option>';
    } catch(e){}
    loadQuestionsFromFile();
  });
}

loadExamList();
// Don't call updateButtonStates here - it will be called after exam loads
// Hide meta bar before starting any exam
try { document.querySelector('.meta').style.display = 'none'; } catch(e){}
</script>
</body>
</html>